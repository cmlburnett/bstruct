bstruct -- binary struct
This overlays a custom struct-like class over binary data to read/write from the binary data without an intermediate storage.
This can be used with a bytearray() or an mmap'ed file to directly modify binary data.

A class is declared using the metaclass "bstructmeta" and the class defines a dictionary named dat that defines the struct.

	import bstruct
	class foo(metaclass=bstruct.bstructmeta):
		dat = {
			'magic': bstruct.member_4(0),
			'length': bstruct.member_8(4),
		}

This creates a two-member struct that includs a 4-byte magic number and an 8-byte length number.
Use of the metaclass creates all of the properties and back-end work to manipulate the binary data.

	# Create a 20 byte null space
	b = bytearray(b'\0'*20)
	# Start struct at byte five
	f = foo(b, 5)

	f.magic.val = 42
	f.length.val = 2346298

	print(b.hex())

This outputs in hex:

	00000000002a0000003acd230000000000000000

Index with where struct members are found:
	00112233445566778899AABBCCDDEEFF00112233
	          | magic |   length   |

Note that 42 = 0x0000002A in little endian is 2a000000
and that 2346298 = 0x000000000023CD3A in little endian is 3acd230000000000

Polymorphism is supported. In the following example, a person can be an employee or a volunteer.
Each has different properties encoded in the person.data binary field.
	import bstruct
	class person(metaclass=bstruct.bstructmeta):
		dat = {
			'type': bstruct.member_1(0),
			'name': bstruct.member_str(1,16),
			'data': bstruct.member_binary(17),
		}
		conditional = {
			'type': {
				'E': employee,
				'V': volunteer,
			}
		}
		@staticmethod
		def lenplan(typ, **kargs):
			if typ == 'E':
				return employee.lenplan(**kargs)
			elif type == 'V':
				return volunteer.lenplan(**kargs)
			else:
				raise Exception
	class employee(metaclass=bstruct.bstructmeta):
		dat = {
			'type': bstruct.member_1(0),
			'name': bstruct.member_str(1,16),
			'ID': bstruct.member_8(17),
			'pay': bstruct.member_4(25),
		}
		@staticmethod
		def lenplan():
			return 29
	class volunteer(metaclass=bstruct.bstructmeta):
		dat = {
			'type': bstruct.member_1(0),
			'name': bstruct.member_str(1,16),
			'hours': bstruct.member_4(17),
		}
		@staticmethod
		def lenplan():
			return 21

On an instance of a person struct, call condition_on(field) to get a polymorphed struct
		b = bytearray(b'\0'*50)
		p = person(b, 0)
		p.type.val = 'E'
		p = p.condition_on('type')
		p.name.val = 'Bob Ross'
		p.ID = 12

		b = bytearray(b'\0'*50)
		p = person(b, 0)
		p.type.val = 'V'
		p = p.condition_on('type')
		p.name.val = 'Bob Dole'
		p.hours.val = 1248

Note that both the person() instance and employee() instance access the exact same data and so they act more like a union.
Each can modify the available fields.

A more advanced feature is a jumptable that is used to store 2-byte offsets (both start and end) of a list of structs.
	import bstruct
	class person(metaclass=bstruct.bstructmeta):
		dat = {
			'num_names': bstruct.member_1(0),
			'index_names': bstruct.member_ref(1),
			'names_jumptable': bstruct.member_jumptable('index_names', 'num_names', 'names'),
			'names': bstruct.member_list('names_jumptable'),
		}
		@staticmethod
		def lenplan(names):
			return 3 + sum([name.lenplan(_) for _ in names])

	class name(metaclass=bstruct.bstructmeta):
		dat = {
			'first': bstruct.member_str(0, 20),
			'last': bstruct.member_str(20, 40),
		}
		@staticmethod
		def lenplan():
			return 40

This creates a struct that contains a jumptable linked to a list of name structs, where each name struct is 40 bytes of a name.
The name struct need not be of fixed size, nor do they need to be byte-wise contiguous as each entry in the jumptable contains a start and end offset.
Arguments to member_jumptable are the members that contain the offset start of the jumptable (index_names), the number of entries (num_names), and the list itself (names).


### Unit Testing ###
Some basic unit testing is included.

	python setup.py test

All should pass, of course.

